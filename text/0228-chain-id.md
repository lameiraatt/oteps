# Chain ID attribute

Add a chain ID attribute to spans and logs.

## Motivation

Spans include information on parent spans that make it possible for observability backends to digest and display span hierarchies within traces.
The availability of such a view is dependent on the used backend and, in a large distributed system that generates a lot of data, it might not be a practical option.

This OTEP introduces the concept of a chain ID attribute that should improve our ability to understand causality while looking at spans individually and also filter spans/logs using chain IDs, facilitating subtree data extraction and analysis.

For instance, let's look at the small span below (exported using the OTLP Exporter) that includes a `chain.id` attribute:

```json
{
  "traceId": "oKgVBuTUDvKapES6R+XB/w==",
  "spanId": "iEmQw+9HZZA=",
  "traceState": "",
  "parentSpanId": "5UT4Dcw3/wg=",
  "name": "AutomationService.execute",
  "startTimeUnixNano": 1676488664356477700,
  "endTimeUnixNano": 1676488664416353000,
  "attributes": [
    {
      "key": "chain.id",
      "value": {
        "stringValue": "2e072d7d02464a2490b65c864da59609#5#31#739#11"
      }
    },
    {
      "key": "task.processing.time.ns",
      "value": {
        "intValue": "37835900"
      }
    },
    ...
  ]
}
```

Chain ID creation logic will be detailed in the [Explanation](#explanation) section, but, for now, we can hint at the fact that the chain links refer to different span levels.
From a single span, without the chain ID, we can say that this isn't a level 0 span, because it has a parent span ID, but because the chain ID is present, we know this span is actually on level 3 of the trace tree and the path to that span is as follows:

* level 0 span - chain ID `2e072d7d02464a2490b65c864da59609#5`
* level 1 span - chain ID `2e072d7d02464a2490b65c864da59609#5#31`
* level 2 span - chain ID `2e072d7d02464a2490b65c864da59609#5#31#739`
* level 3 span - chain ID `2e072d7d02464a2490b65c864da59609#5#31#739#11`

The example span above includes a `task.processing.time.ns` attribute, which represents the amount of time the CPU spent processing the task associated with that span.
If we want to determine the total amount of CPU time spent on all tasks performed under that span (level 3+), we can:

1. Find spans where the `chain.id` attribute value starts with `2e072d7d02464a2490b65c864da59609#5#31#739#11`, to get the entire subtree;
2. Extract `task.processing.time.ns` values, if the attribute is present;
3. Sum.

Without chain ID, we'd have to first create the tree, using span ID and parent span ID information.
When processing big data sets, with millions of data points, generated by thousands of processes, this can have a considerable performance impact.
The presence of chain IDs means that we can not only reduce the complexity of the algorithm used to perform this type of computation, but also easily distribute its execution.

Chain ID links also represent a span count (excluding root) and can, for that reason, provide a measure of how much work has been carried out at different trace levels leading up to the associated span.

## Explanation

With the proposed change we will be enhancing the list of attributes in span and log record data to include a chain ID.
The diagram below illustrates, on a small scale, how the chain ID creation logic follows span hierarchy.

``` mermaid
graph LR
    subgraph p1[Process 1]
        UUID1#1 --> UUID1#1#1
        UUID1#1 --> UUID1#1#2
        UUID1#2 --> UUID1#2#1
        UUID1#3 --> UUID1#3#2
        UUID1#3 --> UUID1#3#1
    end
    subgraph p3[Process 3]
        UUID1#3#2 --> UUID1#3#2-2[UUID1#3#2]
        UUID1#3#2-2[UUID1#3#2] --> UUID1#3#2#1
        UUID3#1 --> UUID3#1#1
        UUID3#1 --> UUID3#1#2
    end
    subgraph p2[Process 2]
        UUID2#1 --> UUID2#1#1
        UUID2#1 --> UUID2#1#2
        UUID1#3#1 --> UUID1#3#1-2[UUID1#3#1]
        UUID1#3#1-2[UUID1#3#1] --> UUID1#3#1#1
        UUID1#3#1-2[UUID1#3#1] --> UUID1#3#1#2
    end
```

The tree nodes represent spans and their labels the associated chain ID string.
The chain begins with a root ID (for readability, we use UUID1, UUID2 and UUID3, instead of actual UUIDs), which is created when the respective process starts running.
If a new level is created the chain grows and a counter is incremented every time a new node is added to that level.
When context propagation takes place between processes, both the client/producer and the server/consumer spans will be associated with the same chain ID.

Logs created in a span's execution context will have the same chain ID as that span.

The details on how to enable this functionality will vary with language and implementation, but it will be offered as a default OpenTelemetry SDK extension, which means that, once it's added as a dependency to the relevant projects, it should rely on SDK configuration changes, with some known exceptions.
For instance, our feasibility experiments were run in Java using auto-instrumentation and, in that case, we implemented an `AutoConfigurationCustomizerProvider` and simply extended the OpenTelemetry Java agent, so neither dependencies nor extension specific configuration changes were required in the test applications.

## Internal details

The code snippets shown in this section are from the Java module created to test the viability of our proposal.

In order to achieve the described functionality we're proposing the creation of a module that contains the following main components:

* chain ID: keeps chain ID string representation and child counter;
* chain ID manager: implements the chain ID creation logic and keeps the association between spans and chain IDs, so that each span is associated with only one chain ID in a process;
* span processor: adds the chain ID attribute to spans;
* log processor: adds the chain ID attribute to logs;
* baggage propagator: wraps the default baggage propagator (following [W3C Baggage Specification](https://w3c.github.io/baggage/)) and adds chain ID to the context baggage before propagation.

The call to create a new chain ID will be made from the span processor to the chain ID manager when a new span is started.

```java
public void onStart(Context parentContext, ReadWriteSpan span) {
    ChainId chainId = chainIdManager.createChainId(parentContext, span.getSpanContext().getSpanId());
    span.setAttribute(ChainId.KEY, chainId.toString());
}
```

When a span ends, the call to delete the created chain ID, and its association with the span, will also be made from the span processor.

```java
public void onEnd(ReadableSpan span) {
    chainIdManager.deleteChainId(span.getSpanContext().getSpanId());
}
```

The log correlation with other observability data by execution context is leveraged within the log processor when a log is emitted.

```java
public void onEmit(ReadWriteLogRecord logRecord) {
    String spanId = logRecord.toLogData().getSpanContext().getSpanId();
    ChainId chainId = chainIdManager.getChainId(spanId);
    if (chainId != null) {
        logRecord.setAttribute(AttributeKey.stringKey(ChainId.KEY),chainId.toString());
    }
}
```

The context is immutable, so when a chain ID is associated with the span context in the context being propagated, baggage is rebuilt to include that chain ID and a copy of the original context containing that baggage will be propagated instead.

```java
public <C> void inject(Context context, @Nullable C carrier, TextMapSetter<C> setter) {
    ChainId chainId = chainIdManager.getChainId(Span.fromContext(context).getSpanContext().getSpanId());

    if (chainId == null) {
        w3CBaggagePropagator.inject(context, carrier, setter);
    } else {
        Baggage extendedBaggage = Baggage.fromContext(context).toBuilder().put(ChainId.KEY, chainId.toString()).build();
        Context extendedContext = context.with(extendedBaggage);
        
        w3CBaggagePropagator.inject(extendedContext, carrier, setter);
    }
}
```

In order to keep the association between spans and chain IDs, the chain ID manager uses a `Map<String, ChainId>` where the key is the span ID.
These key-value pairs are held in memory while a span is active, i.e., from `onStart` to `onEnd`.
As seen above, the chain ID manager is called from the span processor, the log processor and the baggage propagator.
At the moment, the `ChainIdManager` class is a singleton and the only component calling methods that write to the map is our span processor.
The methods in question are `createChainId` and `deleteChainId`, respectively:

```java
ChainId createChainId(Context parentContext, String spanId) {
    String parentSpanId = Span.fromContext(parentContext).getSpanContext().getSpanId();
    ChainId parentChainId = spanIdToChainIdMap.get(parentSpanId);
    
    ChainId chainId = parentChainId == null ? ChainId.fromBaggage(Baggage.fromContext(parentContext)) : parentChainId.child();
    
    spanIdToChainIdMap.put(spanId, chainId);
    
    return chainId;
}
```

```java
ChainId deleteChainId(String spanId) {
    return spanIdToChainIdMap.remove(spanId);
}
```

The log processor and baggage propagator only call the `getChainId` method, which reads from the map.

```java
public ChainId getChainId(String spanId) {
    return spanIdToChainIdMap.get(spanId);
}
```

With multiple components calling the chain ID manager in a way that leads to concurrent reading/writing from/to a map, synchronisation was a concern.
After some analysis, we determined that using a `ConcurrentHashMap` (with default concurrency level) would be the easiest solution to guarantee thread-safety in all three methods.
This is evident for the `deleteChainId` and `getChainId` methods that simply remove and get values from the map.
However, for `createChainId`, there should be further consideration.
This method is called exclusively from the span processor `onStart`, which is called once per span.
Knowing that a parent span must be created before its children, since parent data is added to spans on creation, concurrency in calling the `createChainId` can only happen when we're either starting spans under the same parent or starting spans under different parents.
When the parents are different, there won't be an issue, because different parent spans will be associated with different chain IDs, but when the parent is the same, we can have concurrent calls to `parentChainId.child()`.

```java
public ChainId child() {
    return new ChainId(repr + "#" + childCounter.incrementAndGet());
}
```

As mentioned before, the `ChainId` object contains the chain ID string representation `repr` and a counter `childCounter`.
The latter is an `AtomicInteger`, therefore, concurrent calls to this method should behave properly.

Lastly, in `createChainId`, the case where `parentChainId` is `null` happens when we're processing a span with no parent in the current process.
The `fromBaggage` method of the `ChainId` class tries to get the chain ID representation from the baggage, which should be present in propagated contexts, otherwise, it defaults to `ROOT.child()` (new level 0 span).

```java
static ChainId fromBaggage(Baggage baggage) {
    String chainIdRepr = baggage.getEntryValue(KEY);

    return chainIdRepr == null ? ROOT.child() : new ChainId(chainIdRepr);
}
```

The reason why we generate a UUID per process for root chain ID creation rather than using trace ID is so that we can utilise chain ID to find spans and logs from different traces with the same source process.
We considered using `service.instance.id` but that resource attribute might not be reliably unique or even set.

Our aim is to provide a module containing the described components for each supported language and add those modules to _opentelemetry-*-contrib_ repositories.
It's worth noting that, at the time of writing, Logs API and Logging SDK are still experimental and not all default OpenTelemetry SDK's include the `LogProcessor` interface (`LogRecordProcessor` from OTel Java SDK 1.19.0) implemented by one of our components.

## Trade-offs and mitigations

Using the extra span and log processors, extending the baggage and context in the propagator and managing the association between spans and chain IDs will incur a small overhead (the [Overhead and benchmarks](#overhead-and-benchmarks) section provides an overview of the tests run to assess the performance overhead).
To mitigate this, we considered an alternative approach that added the chain ID attribute to the span on creation and also to the span context trace state for propagation.
This would have reduced the overhead by taking away the need to include a custom propagator or a span processor in our module, but we'd have to change the SDK span builder and introduce configuration to enable chain ID injection.
We'd also have to drop our log processor component and change the SDK log builder to keep the implementation consistent.
However, we decided that modifying default OpenTelemetry SDK builders and configuration properties to incorporate a new non-core attribute was less fitting than providing a clean extension module that could be added whenever chain ID is required.

## Overhead and benchmarks

Java Microbench Harness(JMH) was used to benchmark key components of our implementation against some OTel SDK components.

### Context for all tests

* Windows 10 running on Core i5 quad-core 16G RAM
* JMH core 1.36
* JDK 17.0.6 (Java HotSpot(TM) 64-Bit Server VM)
* OpenTelemetry Java SDK 1.18.0
* Test mode was “avgt” (average time to complete an operation with a variance score)
* Configurations: Fork = 10, Iterations = 10 (100ms per iteration), Warmup = 5 (100ms per iteration) and Output time unit = nanoseconds per operation (ns/op)

Please refer to [OpenJDK JMH](https://github.com/openjdk/jmh#README.md) for setup details.

### SpanProcessor

We measured the time it took to run `onStart` and `onEnd` using different span processors, `ChainIdSpanProcessor` as our test and `SimpleSpanProcessor` (with `NoopSpanExporter`) and `NoopSpanProcessor` as control.

|                                                    | Score   | Error   |
|----------------------------------------------------|---------|---------|
| SpanProcessorBenchmark.onStartChainIdSpanProcessor | 194.985 | ± 2.880 |
| SpanProcessorBenchmark.onStartSimpleSpanProcessor  | 0.741   | ± 0.038 |
| SpanProcessorBenchmark.onStartNoopSpanProcessor    | 0.714   | ± 0.011 |

|                                                  | Score   | Error   |
|--------------------------------------------------|---------|---------|
| SpanProcessorBenchmark.onEndChainIdSpanProcessor | 7.645   | ± 0.208 |
| SpanProcessorBenchmark.onEndSimpleSpanProcessor  | 191.182 | ± 6.687 |
| SpanProcessorBenchmark.onEndNoopSpanProcessor    | 1.457   | ± 0.032 |

### LogProcessor

In this test, we benchmarked the `onEmit` method as it is the only method called from the `LogProcessor` on the event of a `LogRecord` being created.
Here we used the `SimpleLogProcessor` (with `NoopLogExporter`) and `NoopLogProcessor` for comparison.

|                                                 | Score   | Error    |
|-------------------------------------------------|---------|----------|
| LogProcessorBenchmark.onEmitChainIdLogProcessor | 207.010 | ± 18.578 |
| LogProcessorBenchmark.onEmitSimpleLogProcessor  | 222.865 | ± 28.031 |
| LogProcessorBenchmark.onEmitNoopLogProcessor    | 1.441   | ± 0.022  |

### BaggagePropagator

This benchmark test was focused primarily on the `inject` and `extract` methods of the `BaggagePropagator`.
In the first setup, the inject method is called with a context containing an empty baggage.

|                                                                       | Score   | Error    |
|-----------------------------------------------------------------------|---------|----------|
| BaggagePropagatorBenchmark.injectChainIdBaggagePropagatorEmptyBaggage | 644.265 | ± 34.355 |
| BaggagePropagatorBenchmark.injectW3CBaggagePropagatorEmptyBaggage     | 8.637   | ± 0.330  |

In the second setup, the inject method is passed a context containing a 10 key-value pair baggage, where the key and value are both the string representation of numbers 0 to 9.

|                                                                       | Score    | Error     |
|-----------------------------------------------------------------------|----------|-----------|
| BaggagePropagatorBenchmark.injectChainIdBaggagePropagatorSmallBaggage | 2697.731 | ± 327.778 |
| BaggagePropagatorBenchmark.injectW3CBaggagePropagatorSmallBaggage     | 728.066  | ± 51.696  |

The benchmark results show a noticeable difference between the time it takes to run the `inject` method on our `ChainIdBaggagePropagator` vs `W3CBaggagePropagator` with both setups.
This is due to the fact that, in our implementation, as described in the [Internal Details](#internal-details) section, before propagation, we extend the existing baggage to include the chain ID and the existing context to include the extended baggage.

When the baggage is empty, the `W3CBaggagePropagator`'s `inject` will return after a content check, because there's no baggage to propagate, and that's why it takes almost no time to run.
On the other hand, the `ChainIdBaggagePropagator` will turn the empty baggage into one with chain ID, so all the code in the `inject` method will be executed.

The tests for the `extract` method were run with a 10 key-value pair baggage setup.

|                                                                        | Score    | Error     |
|------------------------------------------------------------------------|----------|-----------|
| BaggagePropagatorBenchmark.extractChainIdBaggagePropagatorSmallBaggage | 3316.158 | ± 154.847 |
| BaggagePropagatorBenchmark.extractW3CBaggagePropagatorSmallBaggage     | 3289.697 | ± 151.038 |

Our `ChainIdBaggagePropagator`'s `extract` consists of a call to the wrapped propagator `W3CBaggagePropagator`'s `extract` method and, as expected, the results were very close.

## Open questions

When using messaging systems, we can have situations in which the same message is consumed several times, either by a single consumer, different consumers or both.
Those scenarios lead to multiple consumer spans being associated with the same chain ID, which creates ambiguity.
We can deal with the first scenario by creating a chain ID that is a combination of the propagated chain ID and a count that is incremented every time the propagated chain ID is associated with a consumer span within a process.
For the second scenario, the chain ID associated with the consumer span could be a combination of the propagated chain ID and the current process UUID.
If we apply both strategies we cover the third scenario as well and end up with consumer spans associated with chain IDs following a format that could look like `<propagated chain ID>-<process UUID>-<count>`.

``` mermaid
graph LR
    subgraph p1[Process 1]
        UUID1#1 --> UUID1#1#1
        UUID1#1 --> UUID1#1#2 
        UUID1#2 --> UUID1#2#1
        UUID1#3 --> UUID1#3#2
        UUID1#3 --> UUID1#3#1
    end
    subgraph p4[Process 4]
        UUID1#3#2-UUID4-1
        UUID1#3#2-UUID4-1 --> UUID1#3#2-UUID4-1#1
        UUID4#1 --> UUID4#1#1
        UUID4#1 --> UUID4#1#2
    end
    subgraph p3[Process 3]
        UUID3#1 --> UUID3#1#1
        UUID3#1 --> UUID3#1#2
        UUID1#3#2-UUID3-1 
        UUID1#3#2-UUID3-2 --> UUID1#3#2-UUID3-2#1
    end
    subgraph p2[Process 2]
        UUID2#1 --> UUID2#1#1
        UUID2#1 --> UUID2#1#2
        UUID1#3#1 --> UUID1#3#1-2[UUID1#3#1]
        UUID1#3#1-2[UUID1#3#1] --> UUID1#3#1#1
        UUID1#3#1-2[UUID1#3#1] --> UUID1#3#1#2
    end
    UUID1#3#2 ==> broker[/Message Broker/]
    broker ==> UUID1#3#2-UUID3-1
    broker ==> UUID1#3#2-UUID3-2
    broker ==> UUID1#3#2-UUID4-1
```

This would resolve the ambiguity issue but could also lead to much longer chain IDs in some distributed systems, precipitating the problem discussed in the next paragraph.

One of the reasons why numbers are used as chain ID links instead of UUIDs is to keep the chain ID as short as possible, but, in theory and by design, chain IDs can still become very long.
This raises concerns around propagation due to carrier limits.
For example, if the context is propagated in the headers of an HTTP request, even though the HTTP specification doesn't define any limits, servers usually do and those limits can vary, which makes it hard to find a generic solution to this problem.

## Future possibilities

Chain IDs add support for straightforward analysis of logs and traces, which is especially beneficial when debugging and running complex queries.
Moreover, we can use chain IDs to simplify backend visualisation algorithms and, as a result, boost rendering performance.

Finally, chain IDs are currently an important part of a proprietary observability tool owned by a large multinational that wants to migrate to OpenTelemetry.
Bringing this attribute into OpenTelemetry creates an incentive for further investment in the continuous improvement of OpenTelemetry's ecosystem.
